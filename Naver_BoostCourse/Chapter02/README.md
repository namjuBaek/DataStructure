# 자바로 배우는 자료구조 [Chapter02]

### 선형 자료구조 (연결 리스트 & 배열)

**1-1. 연결 리스트**

- 순차적인 데이터나 많은 양의 데이터를 정리하는 자료구조
- 배열과 마찬가지로 순서대로 여러 데이터를 저장할 때 사용하지만, 연결 리스트는 항상 맞는 크기로 만들어지도록 설계되어 있다.

<br/>



**1-2. 노드와 크기**

- **[생각해보기]** next가 내부 클래스에 있지 않으면 어떤 문제가 발생할까요?
- 외부에서 next에 접근해 값을 바꿀 수 있게 되고 다음 노드의 정보를 잃게 된다.

<br/>



**1-3. 경계 조건 (Boundary Condition)**

- Empty data structure - 자료 구조가 비어있는 경우
- Single element in the data structure - 자료 구조에 단 하나의 요소가 들어있는 경우

- Adding / removing beginning of data structure - 자료 구조의 첫 번째 요소를 추가하거나 제거하는 경우
- Adding / removing end of the data structure - 자료 구조의 마지막 요소를 추가하거나 제거하는 경우
- Working in the middle - 자료 구조의 중간 부분을 처리할 때 (가장 흔함)

- **[생각해보기]** 자료 구조의 첫 번째 요소를 제거하거나 추가할 때 어떤 포인터를 고려해야 하나요?
  - 추가할 때는 추가된 첫 번째 요소가 두 번째 요소를 가리키게 한 뒤, head가 첫 번째 노드를 가리킬 수 있게 설정해야 한다.
  - 제거 시에는 head가 두 번째 노드를 가리킬 수 있도록 바꿔줘야 한다.

<br/>



**1-4. addFirst 메소드**

- 추가된 요소가 기존 첫 번째 노드를 가리키게 한 뒤,  head가 추가된 노드를 가리키도록 작업한다.

- **[생각해보기]** head가 비어있는 경우, 즉 head가 null을 가리키는 경우에 addFirst 메소드를 사용하면 node.next, head가 어떻게 달라지나요?
  - node.next는 head가 가리키는 null을 가리키게 되고, head는 추가된 노드를 가리키게 된다. 맨 앞에 데이터를 추가할 때는 데이터가 비어있어도 문제 없다.

<br/>



**1-5. addLast 메소드**

- 연결리스트의 마지막을 가리키는 임시 포인터를 사용한다.

- **[생각해보기]** 왜 currentSize 변수 대신 tail 포인터를 사용하나요?
  - head부터 접근하면 요소 하나하나 접근해 시간복잡도가 O(n)이 되지만, tail 포인터를 사용하면 마지막 요소를 가리키고 있는 tail에 새로운 요소를 바로 연결할 수 있기 때문에 시간복잡도를 O(1)로 줄일 수 있다.

<br/>

**1-6. removeFirst 메소드**

- **[생각해보기]** tail 포인터의 단점은 무엇입니까?
  - 효율성은 높아지지만 요소가 한 개일 때 구현이 복잡해질 수 있다.

<br/>

**1-7. removeLast 메소드**

- 임시 포인터 current와 previous를 활용해 마지막 - 1 노드를 구함.

<br/>

**1-8. remove와 fiind**

- Comaparable  인터페이스를 사용하여 제거 요소 위치를 찾는다.

- **[생각해보기]** remove와 removeFirst, removeLast 메소드의 차이점은 무엇인가요?
  - removeLast 메소드에서는 current.next == null 또는 tail == current 조건을 사용하여 마지막 노드 이전 노드의 위치를 알아내어 마지막 요소를 제거한다. 그러나 remove에서 current는 while (current != null) 조건을 사용하여 객체 비교가 이루어진 후에 while문이 끝나도록 작업한다.
- **[생각해보기]** 리스트가 비어있는 경우에 remove를 사용하면 어떻게 되나요?
  - current = head로 초기화 되므로, current에 null값이 들어가면서 자동으로 while 조건문 (current != null)에서 걸러지며 제거되지 않고 종료된다.

<br/>

**1-9. peek 메소드**

- 연결리스트 중 하나의 요소를 살펴보는 메소드
- **[생각해보기]** tmp가 임시 포인터라 할 때, while(tmp.next != null)과 while(tmp != null)의 차이점은 무엇인가요?
  - tmp.next로 비교할 때는 포인터가 마지막 요소까지 체크, tmp는 마지막 요소를 지난 후 종료된다.

<br/>

**1-10. 연결리스트 테스트**

<br/>

**1-11. 반복자**

- Iterator 인터페이스 구현
- **[생각해보기]** hasNext는 노드의 어떤 정보를 반환할까요?
  - 다음 노드에 반환할 데이터가 있으면 true를 리턴, null이면 false를 반환합니다.

<br/>

**1-12. 이중 연결 리스트**

- 임시 포인터 previous를 사용하여 현재 노드 이전의 노드를 알 수 있게 연결 리스트를 관리한다.
- **[생각해보기]** 이중 연결 리스트의 장단점은 무엇인가요?
  - 장 : removeLast 메소드의 시작복잡도가 O(n)에서 O(1)로 줄어든다.
  - 단 : removeLast를 제외한 노드 추가 및 삭제 시 연산이 더 복잡해진다.

</br>

**1-13. 원형 연결 리스트**

- 마지막 노드가 연결 리스트 중 하나의 노드를 가리키는 연결 리스트

</br>

**2-1. 스택과 큐**

